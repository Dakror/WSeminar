\documentclass[12pt]{article}
\usepackage[greek, ngerman]{babel}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{algorithm,algpseudocode}
\usepackage{setspace}
\usepackage{ifthen}
\setstretch{1.5}
\usepackage[paper=a4paper,left=25mm,right=35mm,top=25mm,bottom=20mm]{geometry}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pdfpages}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\renewcommand{\figurename}{Abb.}
\def\figureautorefname{Abb.}
\def\algorithmautorefname{Alg.}

\newboolean{figures}
\setboolean{figures}{true} % to test the text amount w/o any code or figures

\floatname{algorithm}{Alg.}

\renewcommand{\algorithmicrequire}{\textbf{geg.:}}
\renewcommand{\algorithmicensure}{\textbf{ges.:}}
\renewcommand{\algorithmicprocedure}{\textbf{prozedur}}
\renewcommand{\algorithmicfor}{\textbf{für}}
\renewcommand{\algorithmicdo}{\textbf{wiederhole}}
\renewcommand{\algorithmicend}{\textbf{ende}}
\renewcommand{\algorithmicrepeat}{\textbf{wiederhole}}
\renewcommand{\algorithmicif}{\textbf{wenn}}
\renewcommand{\algorithmicelse}{\textbf{sonst}}
\renewcommand{\algorithmicthen}{\textbf{dann}}
\renewcommand{\algorithmicreturn}{\textbf{gib zurück}}
\renewcommand{\algorithmicuntil}{\textbf{solange}} % for the classic do ... while
\renewcommand{\algorithmicwhile}{\textbf{solange}}
\newcommand{\sei}{\textbf{sei }}

\includepdf[pages={1}]{res/deckblatt_erklaerung.pdf}

\tableofcontents
\thispagestyle{empty}
\clearpage

\section{Risikofaktor Navigationsgerät}
"`Wenn möglich, bitte wenden"\ auf der Autobahn. "`Jetzt links abbiegen"\ im Kreisverkehr. Navigationssysteme können Todesfallen oder Verursacher schwerer Unglücke sein. Denn die Menschen vertrauen ihnen oft blind. So zum Beispiel erging es einem 33-jährigen im niedersächsischen Einbeck. Denn als die Polizei an der Unfallstelle eintraf, bot sich ihr ein kurioses Bild: Der Pkw steckte auf einer abwärtsführenden Fußgängertreppe fest. Jegliche Versuche des Fahrers, sein Fahrzeug zu befreien, blieben erfolglos. Bedanken darf sich dieser Mann, ebenso wie eine junge Frau, die aufgrund eines Tippfehlers in einem Ort 850 km entfernt vom gewünschten Ziel eintraf, bei der allzu freundlichen Stimme aus der Mittelkonsole \cite{navi}. Darum ist es umso wichtiger, dass "`Navis"\ immer über aktuellste Kartendaten verfügen und auch ausgiebig auf Fehler geprüft werden. 
\\
Aber nicht nur detailreiche Straßeninformationen sind für ein gutes Navigationsgerät von Bedeutung, sondern auch die Verarbeitung dieser. Denn die Daten können noch so genau sein; wenn das Gerät keine vernünftigen Wege berechnen kann, ist es genau so unbrauchbar. Darum geht es in dieser Arbeit, nämlich die verschiedenen Methoden zur Wegberechnung in einem Straßen-\textit{Netz} oder ähnlichem. Es werden drei \textit{Algorithmen} vorgestellt und verglichen, um festzustellen, für welche Zwecke welche Methode am zielführendsten ist. Als Werkzeug zur genaueren Untersuchung und zur Erzeugung von Vergleichsstatistiken habe ich ein Programm namens \textit{PathFinder} geschrieben, in dem die \textit{Algorithmen} adaptiert sind. Die Ausführungen in dieser Arbeit sind in gewisser Weise als Bedienungsanleitung des Programms zu sehen, da sich sämtliche Darstellungen und Tabellendaten darauf stützen. 
\\
Mit der Mathematik als Leitfach, im Themenbereich von Extremwertproblemen, wird konkret das \textit{Problem des kürzesten Wegs} in Angriff genommen. Der optimale, kürzeste Weg zeichnet sich aber nicht nur durch seine Eigenschaft, am schnellsten von \textit{A} nach \textit{B} zu gelangen, aus, sondern auch durch die für die Bestimmung dieses Wegs benötigte Zeit und den Rechenaufwand. Denn ein "`Navi", das vier Stunden rechnet, um den besten Weg zu ermitteln, wird sich nicht bei den Konsumenten durchsetzen. Gleiches gilt aber auch für ein Gerät, welches den Fahrer ohne Rechenzeit über Feld- und Waldwege lotst. Es muss eine \textit{Balance zwischen Quantität und Qualität} gefunden werden. Und wo diese Mitte liegt, gilt es nun herauszufinden.
\newpage

\section{Grundlagen und Terminologie}
\label{sec:basics}
Zunächst werden in diesem Abschnitt die grundlegenden Begriffe der Graphen-Theorie geklärt. Auch Fachbegriffe aus der Implementierung durch die Informatik werden erläutert.
\\
Generell sind \textit{Algorithmen} eine festgelegte Abfolge von Schritten um Daten zu verarbeiten. In der Informatik sind diese einzelnen Schritte Befehle.
\\
Die maximale Laufzeit eines \textit{Algorithmus}, auch genannt \textit{Zeitkomplexität}, wird in der "`big-O"\,-Notation (engl. für "`großes O") in Form des \textit{Landau-Symbols} $O$ angegeben. Dabei werden sämtliche kleineren Polynome aufgrund ihres geringeren Wachstums vernachlässigt. So zum Beispiel lässt sich ein \textit{Algorithmus}, der in der Zeit $O(n^2+5n)$ abläuft, auf die \textit{Komplexität} $O(n^2)$ reduzieren. Hierbei stellt $n$ die Anzahl an \textit{Iterationen}, also Schritten dar. Diese Angabe wird als primäres Vergleichskriterium von \textit{Algorithmen} verwendet \cite{big-o}.
\\
Die Graphen-Theorie dient als Basis dieser Arbeit. Zentrale Bedeutung hat der namensgebende \textit{Graph} $G\; = (V,\,E)$, alternativ auch \textit{Netz} genannt, welcher aus einer Menge von \textit{Knoten} $V$ (von engl. "`Vertex") und einer Menge \textit{Kanten} $E$ (von engl. "`Edge") besteht.
\\
Zeichnerisch werden \textit{Knoten} als Punkte oder Kreise dargestellt; \textit{Kanten} als Verbindungslinien zwischen zwei \textit{Knoten}. Jede \textit{Kante} hat einen \textit{Startknoten} und einen \textit{Endknoten}. 
\\
Sobald sich keinerlei \textit{Kanten} in der Darstellung kreuzen, wird ein \textit{Graph} als \textit{planar} bezeichnet. Wenn von einer \textit{gerichteten Kante} die Rede ist, lässt sich diese als Pfeil interpretieren, da die Verbindung unidirektional gilt. Ebenso gibt es die \textit{gewichteten Kanten}, denen nicht nur zwei \textit{Knoten} zugeordnet werden, sondern zusätzlich noch ein Gewicht $w$ (von engl. "`Weight"), ein Zahlenwert, der als "`Reise"\,-Kosten der Verbindung zwischen den beiden \textit{Knoten} gesehen werden kann.
\\
In der Wegfindung ist ein \textit{Weg} $P$ (von engl. "`Path") als geordnete Abfolge von \textit{Knoten} definiert. Da in der Regel jedes \textit{Knoten}paar nur einfach verbunden ist, reicht in der Implementierung diese Annahme aus.
\\
Unter \textit{Backtracking} versteht man in der Wegfindung das rückwärtige Abbarbeiten der Suchergebnisse eines \textit{Pathfinding-Algorithmus} vom \textit{Zielknoten} aus. 
\\
Somit erhält man den gewünschten Weg als Ergebnis. Visuell wird der \textit{Graph} durch einen \textit{Layout-Algorithmus} dargestellt, der allen \textit{Knoten} durch gewisse Berechnungen Positionen zuteilt (vgl. \autoref{sec:layout}).
\\
Um ein \textit{Netz} zu generieren, wird eine Zufallsfunktion verwendet. Hierzu wird ein standardisierter \textit{Pseudozufalls}-Generator verwendet \cite{random}. Dieser generiert kaum oder nur schwer vorhersagbare Abfolgen von Zahlen. Aufgrund der nicht echten Zufälligkeit wird ein sogenanntes \textit{Seed}-System benutzt, eine spezielle Zahl, mit deren Übergabe an den Generator stets die selbe Zahlenfolge erzeugt werden kann.
\section{Aufbau und Bedienung des Programms \textit{PathFinder}}
\label{sec:manual}
Das selbstgeschriebene Programm \textit{PathFinder}, im eigentlichen Fokus stehend, fungiert sowohl als visuelle Möglichkeit der Darstellung von \textit{Graphen}, als auch als Quelle für Vergleichsdaten und Messungen in selbst erzeugten Szenarien. Geschrieben ist die Anwendung in der Programmiersprache \textit{Java} unter Verwendung der \textit{JavaFX}-Standardbibliothek \cite{javafx} und umfasst über 3000 Zeilen Code in 39 Quelldateien.\footnote{siehe Anhang: CD-ROM}
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.45\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.4\textwidth]{res/main_screenshot.png}
\end{center}
\vspace{-30pt}	
\centering
\caption{Die Start- und Hauptansicht von \textit{PathFinder}}
\label{fig:main_screenshot}
\end{wrapfigure}}{}
Auf den ersten Blick ist die Anwendungsoberfläche in zwei größere Bereiche aufgeteilt. Im linken, kleineren Seitenbereich werden detaillierte Informationen über den \textit{Graphen}, bereits berechnete Wege und die Konfigurationsmöglichkeiten neuer Wege, in mehrere "`Tabs"\ unterteilt, angezeigt. Der große rechte Bereich, zu Beginn der Anwendung nur mit "`Erstellen Sie ein neues Netz..." (\autoref{fig:main_screenshot}) beschriftet, dient als Hauptansicht von sowohl des \textit{Graphen}, als auch der Vergleichsstatistiken und Tabellen.
\\
Die Bedienung kann vollständig mit der Maus erfolgen, da sich sämtliche Funktionen visuell intuitiv und minimalistisch präsentieren. Nur vereinzelt führen Tastatureingaben oder "`Hotkeys"\;zu mehr Komfort oder Genauigkeit der Anwendung. So kann beispielsweise das \textit{Relayout} (siehe \autoref{sec:layout}) des \textit{Graphen} per "`L"\ Taste, das \textit{Generieren} (siehe \autoref{sec:construct}) eines neuen \textit{Netzes} unter Benutzung von "`N"\ erfolgen.
\section{Konstruktion eines Graphen in \textit{PathFinder}}
\label{sec:construct}
Im nächsten Schritt wird nun ein \textit{Graph} erzeugt und die Funktionsweise des Generators betrachtet. Durch Klicken auf "`Erstellen Sie ein neues Netz..."\ wird ein Dialog-Fenster geöffnet (\autoref{fig:new_graph_screenshot}), welches verschiedene Genererierungs-\textit{Parameter}
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.45\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[scale=0.6]{res/new_graph_screenshot.png}
\end{center}
\vspace{-20pt}
\centering
\caption{Dialog zur \textit{Netz}-Generierung}
\label{fig:new_graph_screenshot}
\end{wrapfigure}}{}
zur Konfiguration anbietet.
\\
Unterteilt sind diese Einstellungen in zwei Bereiche: \textit{Generell} und \textit{Erweitert}. \textit{Generelle} Optionen sind für den einfachen Gebrauch ausreichend mit einem Regler für die Größe $s_g$ und ein \textit{Seed}-Eingabefeld ausgestattet. Der \textit{Seed} wird verwendet, um die Möglichkeit zu haben, in späteren Tests mit dem gleichen \textit{Graphen} zu arbeiten.
\\
Im \textit{Erweitert}-Bereich lässt sich die Generierung aufs Genaueste einstellen. So können die Anzahl an Maximalknoten $n_{max}$ und die maximale \textit{Kanten}-Anzahl $e_{max}$ pro \textit{Knoten} festgelegt werden. Ebenso kann die Wahl zwischen drei Typen $t$ von \textit{Kanten} getroffen werden: \textit{Ungerichtet}, \textit{Gemischt} und \textit{Gerichtet}, was alle \textit{Kanten} des zu generierenden \textit{Graphen} betrifft. Die Option \textit{Gemischt} bewirkt, dass die Gerichtetheit jeder \textit{Kante} zufallsbedingt ist.
\\
Durch Bestätigen per Klick auf "`Ok" wird der Generator mit diesen \textit{Parametern} gestartet und ein \textit{Netz} erzeugt.
\\
Zunächst wird der \textit{Seed} für den Zufallsgenerator gesetzt. Danach wird aus den gegebenen Grenzwerten die tatsächliche Menge von \textit{Knoten} berechnet und in den \textit{Graphen} eingesetzt. Daraufhin wird für jeden \textit{Knoten} eine Anzahl an \textit{Kanten} bestimmt. Durch das "`Clampen", d.h Einzwicken, Eingrenzen, der Start- und Generierungswerte mit
\vspace{-20pt}
\begin{gather*}
e = max\Big(1,\,R\Big(0,\;min\Big(\dfrac{n}{2}-1,\,e_{max}\Big)\Big)\Big) \\
\left(\begin{aligned}
max(a, b) \to \text{Größere der beiden Parameter}\\
min(a, b) \to \text{Kleinere der beiden Parameter}
\end{aligned}
\right)
\end{gather*}
wird gewährleistet, dass der Generator nicht mehr \textit{Kanten} platzieren kann, als eindeutig möglich ist. Jetzt wird versucht, sämtliche \textit{Knoten} durch zufällige Wahl mit einem anderen \textit{Knoten} zu verbinden, wobei der jeweils gesuchte \textit{Knoten} weder der \textit{Ausgangsknoten} selbst, noch ein bereits verbundener \textit{Knoten} sein soll. Sobald eine Kombination gefunden wurde, wird die
\ifthenelse{\boolean{figures}}{
\begin{algorithm}
\caption{\textit{Graph-Generator} \label{alg:generator}}
\begin{algorithmic}[1]
\Statex
\Require {Zufallsgenerator R, max. Kantengewicht $W_{max} = 30$}
\Ensure {Graph g}
\Statex
\Procedure{generiereGraph}{$seed$, $s_g$, $n_{max}$, $e_{max}$, $t$}
	\State setze Seed von $R$ zu $seed$
	\State \sei $n$ $R(n_{max}/2,\,n_{max}) * s_g$ \Comment Zufällige Anzahl im Interval $\big[n_{max}/2;\;n_{max}\big[$
	\State füge $n$ $Knoten$ zu $g$ hinzu
	\For {$i=0 \to n$}
		\State \sei $e$ $max(1,\,R(0,\;min(n/2-1,\,e_{max})))$
		\For {$j=0 \to e$}
			\State \sei $index$ $i$
			\Repeat 
			\State \sei $index$ $R(0,\,n)$
			\Until $index$ gleich $i$ oder $Knoten_i$ mit $Knoten_{index}$ verbunden
			\State \sei $e$ Kante von $Knoten_i$ zu $Knoten_{index}$, Gewicht $w = R(0, W_{max})$
			\If {$t =$ \textsc{Gemischt} oder $(t =$ \textsc{Gerichtet} und $R() > R())$} \State \Comment $R>R =$ Zufallstest
				\State setze $e$ gerichtet
			\EndIf
			\State füge $e$ zu $g$ hinzu
		\EndFor
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}}{}
entsprechende \textit{Kante} mit einem ebenfalls zufallsgenerierten \textit{Gewicht} erstellt. Dann wird auf Basis des \textit{Kanten-Typs} die Gerichtetheit bestimmt und schließlich wird die \textit{Kante} im \textit{Graphen} platziert (\autoref{alg:generator})\footnote{vgl. Anhang: GraphGenerator.java}.
\section{Visuelles Layout von Graphen}
\label{sec:layout}
In vorangegangen Abschnitten wurde das grundlegende Konzept eines \textit{Graphen} bereits dargestellt. Wenn man sich nun mit der optimalen visuellen Darstellung eines \textit{Graphen} auseinandersetzt, begibt man sich in die Thematik der \textit{Layouts} (von engl. "`Anordnung") eines \textit{Graphen}.
\\ 
Es gibt die verschiedensten Ansätze, zu einer übersichtlichen Visualisierung zu gelangen, darunter die \textit{force-directed algorithms} (von engl. "`kraft-gerichtet"\ oder "`kraft-basiert")\cite{force-directed}. Diese simulieren ein einem großen Molekül ähnelndes Konstrukt, in dem verschiedene \textit{Kräfte}, die von \textit{Knoten} und \textit{Kanten} ausgehen, aufeinander wirken. Das Ziel solcher Simulationen ist das \textit{mechanische Equilibrium}, die gegenseitige Aufhebung jeglicher wirkenden \textit{Kräfte}.
\\
Vorteile dieser Methode sind die enorme Flexibilität der Simulation und die sehr zufriedenstellenden Resultate in Bezug auf die \textit{Planarität} des visualiserten \textit{Graphen}. Als Nachteil lässt sich die mitunter sehr lange Laufzeit der Berechnung sehen, die benötigt wird, um ein akzeptables Ergebnis zu erhalten; insbesondere bei sehr großen \textit{Netzen}.
\\
Der in \textit{PathFinder} verwendete \textit{Algorithmus} ist der \textit{Fruchtermann-Reingold Algorithmus}\footnote{\cite[Kapitel 12.3, S. 386f]{force-directed2}}, der 1991 von Thomas M. J. Fruchterman und Edward M. Reingold an der University of Illinois veröffentlicht wurde \cite{fruchterman}. Ihre Methode verfolgt die Prinzipien, dass
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.4\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/graph_2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{F.-R. \textit{Algorithmus}}
\label{fig:graph_2}
\end{wrapfigure}}{}
verbundene \textit{Knoten} nebeneinander liegen und sämtliche \textit{Knoten} trotzdem nicht zu nahe beieinander platziert werden sollten.
\\
Der Algorithmus versucht außerdem, alle \textit{Knoten} $n$ gleichmäßig innerhalb eines Rahmens zu verteilen, einer als Parameter $w$ und $h$ (von engl. "`width"\ und "`height") definierten Maximalfläche. Zunächst wird die Konstante $k$, die optimale Distanz zwischen \textit{Knoten}, als
\[
k = \sqrt{\dfrac{w \cdot h}{n}} 
\]
definiert. Sie findet Verwendung in den beiden \textit{Kräften} der Simulation. Die \textit{Kraft} $F_a$ beschreibt die Anziehung zwischen \textit{Knoten}, $F_r$ die Abstoßung dieser voneinander.
\[
 F_a(x) = \dfrac{x^2}{k} \hspace{50pt} F_r(x) = \dfrac{k^2}{x}
\]
Der Ablauf der Simulation lässt sich in drei Schritte zusammenfassen. Zuerst wird $F_a$, danach $F_r$, für jeden einzelnen \textit{Knoten} berechnet. Im dritten Schritt werden die Effekte dieser berechneten \textit{Kräfte} umgesetzt (\textit{Disposition}), aber nur in durch die \textit{Temperatur} begrenzter Länge. Die \textit{Temperatur} ist ein Wert, der bei jedem Durchlauf des \textit{Algorithmus} bis auf $0$ verringert wird, um die Verschiebungen der \textit{Knoten} immer präziser werden zu lassen. Anfangs wird der Wert beliebig festgelegt. Der vorgeschlagene und damit auch in \textit{PathFinder} umgesetzte Startwert $t_0$, dessen Änderung auf der Funktion  $t(s)$ abgebildet wird, entspricht
\[
t_0 = \dfrac{1}{10} \cdot w \hspace{50pt} t(s) = t_0 - \dfrac{t_0}{s_{max}} \cdot s \hspace{50pt} s_{max} = s_g \cdot 500
\]
Außerdem wird eine Maximalanzahl an Simulationsschritten $s_{max}$  definiert, in deren Abhängigkeit die \textit{Temperatur} verringert wird. Die Maximalgröße wird wie angegeben berechnet, wobei $s_g$ die bei der \textit{Graph}-Erzeugung angegebene \textit{Größe} ist. Somit erhält man in \textit{PathFinder} folgende Gesamtfunktion: 
\[
t(s) = \dfrac{w}{10} - \dfrac{w}{s_g \cdot 5000} \cdot s
\]
\section{Wegfindungs-Algorithmen}
Nachdem jetzt sowohl das Programm \textit{PathFinder}, als auch die darin angewandten Methoden zur Generierung und Visualisierung von \textit{Graphen} erläutert worden sind, wird nun auf die Wegfindung eingegangen.
\\
Generell ist das Ziel des \textit{Pathfindings} den kürzesten, optimalen oder hinderniss-ärmsten Weg zwischen zwei \textit{Knoten} zu finden, je nach Aufgabenstellung; und das so schnell und recheneffizient wie möglich. Nun könnte man ganz pragmatisch an die Umsetzung herangehen und einfach den Weg zwischen jedem im \textit{Graphen} existierenden \textit{Knoten}paar vorberechnen und abspeichern. Somit können in der Situation selbst alle notwendigen Wegdaten bequem und schnell abgerufen werden. Nur hat ein solcher \textit{Algorithmus} eine \textit{Zeitkomplexität} $O(V^2)$, die für größere \textit{Graphen} einfach untragbar ist (vgl. \autoref{sec:dijk}). Außerdem wächst die benötigte Speicherkapazität in gleichem Maße.
\\
Man kann also nicht alles vorberechnen, sondern muss einen Großteil in "real time", also Echtzeit berechnen. In dieser Arbeit wird nur auf die vollständig in Echtzeit ablaufenden Umsetzungen eingegangen, doch \textit{Algorithmen} wie \textit{Kontraktions-Hierarchien}, die im Voraus eine kompaktere und performantere Version des gesamten \textit{Graphen} errechnen, sind, besonders in sehr großen Netzwerken oder Systemen, von Bedeutung, da diese trotz des höheren Rechenaufwands enorm zu einer schnelleren Laufzeit beitragen \cite{contr-hier}.
\\
Die nun folgenden Untersuchungen der einzelnen \textit{Algorithmen} werden alle auf den gleichen \textit{Graphen} angewandt. Es wird ein \textit{großer Graph} eingestellt und der Seed als $101115$ bestimmt. Es wird immer der Weg vom \textit{Knoten} Nr. 18 zu Nr. 14 gesucht.
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.25\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.15\textwidth]{res/path_cfg.png}
\end{center}
\vspace{-20pt}
\centering
\caption{Weg-Konfiguration}
\label{fig:path-cfg}
\end{wrapfigure}}{}
Um in \textit{PathFinder} Wege berechnen zu lassen, muss auf der linken Seite des Programms der "`Wege"\,-Tab ausgewählt sein. (\autoref{fig:path-cfg}). Im oberen Teilbereich der erscheinenden Bedienungsoberfläche werden bereits erzeugte Wege mit Details über \textit{Start-} und \textit{Zielknoten}, als auch \textit{Gesamtgewicht} und \textit{Algorithmus} angezeigt. Durch Selektion eines Weges wird dessen Verlauf in der Hauptansicht des \textit{Graphen} angezeigt. Außerdem werden durch die Selektion automatisch \textit{Start-} und \textit{Zielknoten} für eine mögliche Suche des gleichen Wegs, nur mit einer anderen Methode festgelegt, und farbig hervorgehoben (grün = Start, rot = Ziel)(vgl. \autoref{fig:dfs}). Denn das Programm erlaubt nur die einmalige Suche von genau identischen Wegen mit dem selben \textit{Algorithmus}.
\\
Im unteren Bereich können \textit{Start-} und \textit{Zielknoten} manuell in der \textit{Graph}anzeige vorgenommen werden. Zudem kann der gewünschte \textit{Algorithmus} ausgewählt werden und es wird eine Schaltfläche "`animiert"\ angeboten. Durch deren Aktivierung wird die Funktionsweise der Suche Schritt für Schritt nachvollziehbar und verzögert dargestellt.
\subsection{Gröbste Züge von Intelligenz: Tiefensuche}
Die Tiefensuche, oder kurz DFS (von engl. "`depth first search"), hat ihren Namen von ihrer Funktionalität. Der Kerngedanke hinter dem \textit{Algorithmus} ist das kontinuierliche "`Gehen"\ in eine Richtung, sprich der \textit{Graph} wird so lange wie möglich in eine Richtung \textit{traversiert} (lat. für "`entlang gehen") und erst sobald das Voranschreiten nicht mehr gegeben ist, werden Schritte zurückgegangen und andere Richtungen gewählt.
\\
Die Richtung wird in \textit{PathFinder} durch das \textit{Kantengewicht} bestimmt. Es werden alle anliegenden \textit{Kanten} eines \textit{Knoten} der Größe nach sortiert und die Unbesuchte mit dem geringsten \textit{Gewicht} wird gewählt. Das setzt sich so lange fort, wie es noch unbesuchte \textit{Knoten} im \textit{Netz} gibt, oder das Ziel nicht erreicht wurde. Falls ein Weg gefunden wird, so wird, wie in allen weiteren vorgestellten \textit{Algorithmen}, \textit{Backtracking} angewandt\footnote{\cite[Kapitel 22.3, S. 457f]{cormen}}. Der Weg wird also \textit{rückwärts} über die \textit{Vorgänger} konstruiert.
\\
Die Tiefensuche hat eine \textit{Zeitkomplexität} von $O(V + E)$\footnote{\cite[Kapitel 22.3, S. 459]{cormen}}, wobei $V$ der Anzahl an \textit{Knoten}, und $E$ der Anzahl an \textit{Kanten} entspricht. \autoref{fig:dfs} zeigt das Ergebnis der
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.41\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/dfsV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Ergebnis der Tiefensuche}
\label{fig:dfs}
\end{wrapfigure}}{}
Tiefensuche im Fallbeispiel des Wegs von \textit{Knoten} 18 zu 14. Es ergeben sich die Gesamtkosten $w_{dfs} = 116$ durch Addition aller $e_{dfs} = 10$ verwendeten \textit{Kantengewichte}. Die gemessene Laufzeit der Wegsuche beträgt $t_{dfs} = 72,61709\mu s$. Hierbei ist zu beachten, dass aufgrund von variierender Prozessorauslastung und Speicherbelegungen starke zeitliche Schwankungen zwischen wiederholten Suchabläufen bestehen. Aus diesem Grund ist die angegebene Laufzeit der Durchschnitt aus 100 aufeinanderfolgenden Abläufen.
\\
Im Gegensatz zu den nachfolgend vorgestellten \textit{Algorithmen} ist die Tiefensuche in \textit{PathFinder} \textit{rekursiv}, statt \textit{iterativ}, implementiert. Das bedeutet, dass die Suche aus
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{L}{0.41\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/dfs_timeV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Verhalten der Tiefensuche}
\label{fig:dfs-time}
\end{wrapfigure}}{}

\noindent ineinander verschachtelten Funktionsaufrufen besteht. Die Such-Funktion ruft sich selbst also mit neuen Parametern, dem aktuell untersuchten \textit{Knoten} und dessen \textit{Vorgänger}, selbst wiederholt auf und setzt so die Suche fort. Diese Verschachtlung wird entweder durch das Erreichen des \textit{Zielknotens} oder der vollständigen Untersuchung des \textit{Graphen} abgebrochen. Das hat mitunter negative Auswirkungen auf die Laufzeit, vereinfacht aber die Programmierung. 
\\
Neben der Gesamtlaufzeit wird in \textit{PathFinder} ebenfalls das Verhalten der \textit{Algorithmen} aufgezeichnet. So kommt das Liniendiagramm in \autoref{fig:dfs-time} zustande. Es werden Werte wie die Anzahl an inspizierten \textit{Knoten}, bzw. \textit{verschiedenen Knoten}, und Nummer von \textit{Sortier}-Vorgängen in ein Anzahl-Zeit Diagramm eingetragen. Auf Daten wie die \textit{Open-} und \textit{Closed-List} Größe wird in \autoref{sec:astar} eingegangen. Aus der Grafik lässt sich die lineare Funktionsweise der Tiefensuche herleiten, da sämtliche Graphen durch Mittelungsgeraden abgebildet werden können. Dies gibt weiteren Aufschluss auf die geringe \textit{Intelligenz} der Tiefensuche, da sie keine Annäherungen an den \textit{Zielknoten} versucht, sondern den gesamten \textit{Graphen} gleichmäßig absucht.
\\
Um den Codeauszug in \autoref{alg:dfs}\footnote{vgl. Anhang: DFS.java} möglichst gering zu halten, wird hier die \textit{iterative} Version vorgestellt. Dabei erfolgt die Suche durch eine \textit{explizit} festgelegte Wiederholungsschleife "`solange [...] wiederhole"(\autoref{alg:dfs}, Z. 4). 
\ifthenelse{\boolean{figures}}{
\begin{algorithm}
\caption{\textit{Tiefensuche} \label{alg:dfs}}
\begin{algorithmic}[1]
\Statex
\Require{Graph $G = (V,\ E)$}
\Ensure{Weg $P_{ab}$ von $n_a$ nach $n_b$}
\Statex
\Procedure{tiefenSuche}{$n_a$, $n_b$}
	\State markiere alle \textit{Knoten} in $G$ als $unbesucht$, außer $n_a$
	\State \sei $n_x$ aktiver \textit{Knoten} $n_a$
	\While{nicht alle \textit{Knoten} $besucht$ sind}
		\If{$n_x$ ist $n_b$}
			\State erschließe Weg $P_{ab}$ durch \textit{Vorgänger} und beende Suche
		\EndIf
		\If{$n_x$ keine unbesuchten Nachbarn hat}
			\State \sei $n_x$ \textit{Vorgänger} von $n_x$
		\Else
			\State sortiere unbesuchte Nachbarn von $n_x$
			\State \sei $n_{next}$ unbesuchter Nachbar mit geringstem \textit{Kantengewicht}
			\State setze $n_x$ als \textit{Vorgänger} von $n_{next}$
			\State \sei $n_x$ $n_{next}$
		\EndIf
	\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}}{}
\\
Durch den "`brute-force"\,-Charakter (engl. für "`rohe Gewalt") der Tiefensuche ist ihr Einsatz in Szenarien von großen Graphen und benötigter hoher Rechengeschwindigkeit nicht zu empfehlen, denn das simple Ausprobieren von beinahe allen möglichen Wegen ist in keiner Weise als effizient, geschweige denn "`intelligent"\ zu bezeichnen. Tatsächlich wird der \textit{Algorithmus} hauptsächlich für einen komplett anderen Zweck als die Wegfindung zwischen zwei \textit{Knoten} verwendet. Vielmehr kommt er beim \textit{Traversieren} des gesamten \textit{Graphen} zum Einsatz, um beispielsweise einen gewissen \textit{Knoten} zu suchen oder den \textit{Graphen} in einen \textit{depth-first Baum}, also eine alternative Variante der Datenrepräsentation, umzuwandeln. In der Datenverarbeitung entspricht ein \textit{Baum} bildlich einem umgedrehten natürlichen Baum mit einer Wurzel und sich immer weiter aufteilenden, einzelnen "`Ästen"\, und stellt somit eine Daten-\textit{Hierarchie} dar.
\subsection{Erfunden in 20 Minuten: Der Dijkstra-Algorithmus}
\label{sec:dijk}
"`{\em Eines Morgens war ich mit meiner Freundin in Amsterdam shoppen, und müde setzten wir uns in ein Terassencafé, tranken eine Tasse Kaffee [...] und dann entwarf ich den Algorithmus. Wie gesagt, es war eine 20-Minuten Erfindung.}"\footnote{\cite[(engl.), S. 42f]{interview}} (Edsger W. Dijkstra).
\\
Im Zusammenhang mit seiner Präsentation für die Eröffnung des ARMAC\footnote{Automatische Rechenmaschine Mathematisches Zentrum, Amsterdam} 1956, entwarf der niederländische Informatiker Edsger Wybe Dijkstra einen \textit{Algorithmus} zur Ermittlung des kürzesten Wegs von Rotterdam nach Groningen -- in einem Café, innerhalb von 20 Minuten. Der \textit{Algorithmus} (\autoref{alg:dijkstra})\footnote{vgl. Anhang: Dijkstra.java} funktioniert wie folgt:
\ifthenelse{\boolean{figures}}{
\begin{algorithm}
\caption{\textit{Dijkstra-Algorithmus} \label{alg:dijkstra}}
\begin{algorithmic}[1]
\Statex
\Require{Graph $G = (V,\ E)$}
\Ensure{Weg $P_{ab}$ von $n_a$ nach $n_b$}
\Statex
\Procedure{Dijkstra}{$n_a$, $n_b$}
	\State setze die \textit{Distanz} jedes  \textit{Knotens} auf $\infty$
	\State \sei $Q$ Liste aller \textit{Knoten}
	\State setze \textit{Distanz} von $n_a$ auf $0$
	\While{$Q$ nicht leer ist}
		\State \sei $u$ \textit{Knoten} mit geringster \textit{Distanz} aus $Q$
		\If{$u$ ist $n_b$}
			\State erschließe Weg $P_{ab}$ durch \textit{Vorgänger} und beende Suche
		\EndIf		
		
		\State entferne $u$ aus $Q$
		\For{jeden \textit{Nachbarn} $l$ von $u$}
			\State \sei $a$ $Distanz_u + Kantengewicht_{ul}$
			\If{$a < Distanz_l$}
				\State setze \textit{Distanz} von $l$ auf $a$
				\State setze $u$ als \textit{Vorgänger} von $l$
			\EndIf
		\EndFor
	\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}}{}
\newpage
\noindent Zunächst wird die \textit{Distanz}, also die Entfernung vom \textit{Startknoten} $n_a$ aus, auf $\infty$ gesetzt. Nicht dass die Entfernung tatsächlich als unendlich betrachtet wird, sondern 
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}[10]{l}{0.41\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/dijkV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Ergebnis von Dijkstras \textit{Algorithmus}}
\label{fig:dijk}
\end{wrapfigure}}{}
dieser "`Wert"\ gilt auch als Zeichen, dass die entsprechenden \textit{Knoten} noch unbesucht sind.
\\
Schnellere, aber dadurch komplexere, Umsetzungen des \textit{Algorithmus} verwenden statt einer einfachen Liste $Q$ eine \textit{Priority-Queue} (für engl. "`Prioritäts-Warteschlange"), die auch interne Sortieroptimierungen zur Steigerung der Gesamtlaufzeit verwendet. Eine Liste lässt sich als normale Auflistung der einzelnen Elemente ansehen, die keinerlei Sonderberechnungen vornimmt, wodurch die \textit{Zeitkomplexität} $O(V^2)$ beträgt. 
\\
Diese Auflistung wird nun Stück für Stück, in sortierter Reihenfolge, abgearbeitet. Für die \textit{Nachbarn} des aktuell \textit{günstigsten Knotens} wird die
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}[5]{r}{0.275\textwidth}
\vspace{-30pt}
\begin{center}
\includegraphics[width=0.25\textwidth]{res/greed.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Problem von \textit{Greedy Algorithmen}}
\label{fig:greed}
\end{wrapfigure}}{}

\noindent \textit{Distanz} vom \textit{Startknoten} $n_a$ aus berechnet, und gegebenenfalls ausgebessert, falls ein kürzerer Weg gefunden werden sollte. Sobald der \textit{Zielknoten} zur Behandlung ansteht, wird die Suche beendet, da ausreichend Schritte erfolgt sind. Dijkstras \textit{Algorithmus} unternimmt also, im Gegensatz zur zuvor behandelten Tiefensuche, intelligente Schritte zur Eingrenzung des \textit{Zielknotens}. 
\\
Darum zählt der Dijkstra-\textit{Algorithmus} zur Kategorie der \textit{Greedy-Algorithmen}, die
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}[9]{L}{0.41\textwidth}
\vspace{-30pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/dijk_timeV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Verhalten des Dijkstra-\textit{Algorithmus}}
\label{fig:dijk-time}
\end{wrapfigure}}{}

\noindent sich durch die Eigenschaft auszeichnen, von ihrem aktuellen Standpunkt aus immer das  nächste \textit{lokale Maximum} zu suchen. \autoref{fig:greed} veranschaulicht die Problematik von dieser Art \textit{Algorithmus}, denn es wird nicht das globale Maximum von $1 \to 4 \to 65 = 70$, sondern nur das jeweils lokale Maximum, mit einem Ergebnis von 53, erzielt.
\\
Im direkten Vergleich von \autoref{fig:dfs} und \autoref{fig:dijk} wird ersichtlich, dass Dijkstras \textit{Algorithmus} zu einem \textit{besseren} Ergebnis gekommen ist. In der \textit{Durchschnitts}-Messung ergeben $t_{dijkstra} = 223,76864\mu s$ deutlich mehr Zeitaufwand als bei der Tiefensuche. Denn es werden mehr \textit{Knoten}-Abfragen $n_{dijkstra} = 115$ durchgeführt und durch die \textit{Warteschleifenfunktionsweise} von $Q$ werden die bisherigen Suchergebnisse $sort_{dijkstra} = 30$ mal umsortiert (vgl. \autoref{alg:dijkstra}, Z. 6). Durch die $32$ Überschreibungen, die im Fallbeispiel stattfinden, wird ein sehr viel besseres Ergebnis erreicht. Denn so kommt der Dijkstra-Algorithmus in $e_{dijkstra} = 6$ Schritten mit einem \textit{Gesamtgewicht} von $w_{dijkstra} = 78$ zum \textit{Zielknoten}.
\\
Anders als die Tiefensuche findet der \textit{Dijkstra}-Algorithmus tatsächlich Verwendung in der Wegfindung, auch bei Navigationsgeräten. Denn schließlich wurde er dazu entworfen, den kürzesten Weg zwischen zwei Städten zu finden. Allerdings werden heute zahlreich optimierte Versionen verwendet, darunter der A*-\textit{Algorithmus}, der als Nächstes und Letztes untersucht wird.
\subsection{Der Alleskönner: Der A*-Algorithmus}
Der größte Nachteil des zuvor behandelten Dijkstra-\textit{Algorithmus} ist das Besuchen von zu vielen Knoten, die von Anfang an aus der Suche ausgeschlossen werden könnten. Der A* (gesprochen "`A star"\ oder "`A Stern") -\textit{Algorithmus} basiert auf Dijkstras Konzept, doch er erzielt weitaus bessere Ergebnisse durch die Verwendung von \textit{Heuristiken}.
\\
Erstmals veröffentlicht wurde der A*-\textit{Algorithmus} 1968 von Peter Hart, Nils Nilsson und Bertram Raphael, am Stanford Research Institute\footnote{Heute bekannt als SRI International} \cite{astar}.
\\
Kern des von ihnen vorgestellten \textit{Algorithmus} ist die \textit{Kosten}-Funktion
\[
f(n) = g(n) + h(n)
\]
die sich aus einer Funktion der \textit{tatsächlichen Kosten} $g(n)$ und den \textit{heuristischen Kosten} $h(n)$ zusammensetzt.
\\
\textit{Heuristik} (von altgr. \textgreek{εὑρίσκειν} \textit{heuriskein} "`entdecken") wird die Methode der Problemlösung trotz unzureichendes Wissens genannt. Genauigkeit und Vollständigkeit der Lösung werden gegen Geschwindigkeit eingetauscht. Denn \textit{heuristische} Ansätze verwenden Schätzungen und Behauptungen, die die "`Zukunft", also einen zukünftigen Stand der Simulation oder Problemsituation betreffen, und handelt nach diesen. Peter M. Todd und Gerd Gigerenzer verfassten 1999 ein \textit{Paper} zu \textit{Heuristik} und \textit{rationalem Denken}, "`Simple heuristics that make us smart"\cite{heuristics}, worin beschrieben wird, wie \textit{heuristische Schätzungen} beim Treffen von Entscheidungen im Gehirn eine Rolle spielen. Im A*-\textit{Algorithmus} wird die \textit{heuristische} Komponente $h(n)$ zur Eingrenzung der Suche zum \textit{Zielknoten} verwendet. 
\\
Wie im Kontext von Straßennetzen üblich, wird $h(n)$ in \textit{PathFinder} durch die "`Luftlinie"\ zwischen zwei \textit{Knoten} repräsentiert, also die \textit{pythagoräische Distanz} $d = \sqrt{(\Delta x)^2 + (\Delta y)^2}$ der \textit{Knoten} voneinander.
\label{sec:astar}
\ifthenelse{\boolean{figures}}{
\begin{algorithm}
\caption{\textit{A*-Algorithmus} \label{alg:astar}}
\begin{algorithmic}[1]
\Statex
\Require{Graph $G = (V,\ E)$}
\Ensure{Weg $P_{ab}$ von $n_a$ nach $n_b$}
\Statex
\Procedure{aStar}{$n_a$, $n_b$}
\State \sei $O$ Open-List
\State \sei $C$ Closed-List
\State setze $g$ von $n_a$ auf 0 und errechne $h$ von $n_a$
\State füge $n_a$ zu $O$ hinzu
\While{$O$ nicht leer ist}
	\State \sei $u$ \textit{Knoten} mit geringstem $f_u = g_u + h_u$ aus $O$ 
	\State verschiebe $u$ von $O$ nach $C$
	\If{$u$ ist $n_b$}
		\State erschließe Weg $P_{ab}$ durch \textit{Vorgänger} in $C$ und beende Suche
	\EndIf
	\For{jeden \textit{Nachbarn} $l$ von $u$}
		\If{$l$ in $O$ ist}
			\State aktualisiere $f_l$ und \textit{Vorgänger}, falls günstiger
		\ElsIf {$l$ nicht in $C$ ist}
			\State setze $g_l = g_u + Kantengewicht_{ul}$ und errechne $h_l$
			\State setze $u$ als \textit{Vorgänger} von $l$
			\State füge $l$ zu $O$ hinzu
		\EndIf
	\EndFor
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}}{}
\\
Hier kommen zum ersten Mal die Begriffe \textit{Open-List} und \textit{Closed-List} (vgl. \autoref{alg:astar}\footnote{vgl. Anhang: AStar.java}, Z. 2f) vor, die auch in den Verhaltensdiagrammen (vgl. \autoref{fig:dfs-time}, \ref{fig:dijk-time}, \ref{fig:astar_time}) referenziert werden. In der \textit{Open-List} werden alle \textit{Knoten} aufgeführt, die als mögliche nächste Schritte in der Wegsuche gesehen werden. Der jeweils günstigste \textit{Knoten} aus dieser Liste wird für den nächsten Schritt ausgewählt (Z. 7) und in die \textit{Closed-List}, also die engere Auswahl aus \textit{Knoten}, verschoben (Z. 8). In dieser Sammlung finden sich nun alle \textit{Knoten}, die bei der Wegkonstruktion durch \textit{Backtracking} bei Beendung des Suchvorgangs betrachtet werden. Dies ist auch der einzige große 
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}{l}{0.41\textwidth}
\vspace{-30pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/astarV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Ergebnis des A*-\textit{Algorithmus}}
\label{fig:astar}
\end{wrapfigure}}{}
Unterschied zum Dijkstra-\textit{Algorithmus}. Der restliche Verlauf des \textit{Algorithmus} ist fast identisch mit Abbruch bei Erreichen des \textit{Zielknotens}, \textit{Überschreiben} bei Entdeckung von Abkürzungen und \textit{nachbar}-basierter \textit{Graph-Erkundung}. Neben der bereits beschriebenen \textit{Heuristik}-Komponente $h(n)$ verwendet A* auch eine berechnete Komponente $g(n)$, die aus der Summe der \textit{Kantengewichte} besteht (Z. 16).
\\
Bei Beobachtung des \textit{Algorithmus} stellt man fest, dass zu Beginn keine klare Suchrichtung erkennbar ist, doch schon bald sehr zielstrebig vorgegangen und auf schnellstem Wege ein Ergebnis herbeigeführt wird (vgl. \autoref{fig:astar_time}). In nur $t_{astar} = 109,71132\mu s$ findet A* einen Weg mit $w_{astar} = 94$ in $e_{astar} = 6$ Schritten. Er benötigt somit weniger als halb so lange wie der Dijkstra-\textit{Algorithmus}, 
\ifthenelse{\boolean{figures}}{
\begin{wrapfigure}[10]{l}{0.41\textwidth}
\vspace{-20pt}
\begin{center}
\includegraphics[width=0.375\textwidth]{res/astar_timeV2.png}
\end{center}
\vspace{-30pt}
\centering
\caption{Verhalten des A*-\textit{Algorithmus}}
\label{fig:astar_time}
\end{wrapfigure}}{}

\noindent erzielt aber ein nur geringfügig schlechteres Ergebnis. Am Bedeutendsten ist jedoch die geringe Anzahl an besuchten \textit{Knoten}. Während Dijkstra 115 (nicht verschiedene) \textit{Knoten} besucht, benötigt A* nur 29, um zum Resultat zu gelangen.
\\
Aus diesem Grund ist der A*-\textit{Algorithmus} auch der meistverbreiteste der \textit{Pathfinding-Algorithmen}, besonders im Kontext von Computerspielen. Schnelle und akzeptable Lösungen und ein flexibles Konzept machen A* so attraktiv. Zudem gibt es einige optimierte Fassungen, darunter die Verwendung eines \textit{Fast-Stacks} (für engl. "schneller Stapel"), in dem alle Knoten der \textit{Open-List} platziert werden, die den gleichen, und vorallem höchsten Gesamtwert $f(n)$ besitzen, was den Sortierungsprozess der \textit{Open-List} um einige \textit{Knoten} reduziert und so für noch mehr Geschwindigkeit sorgt. Allgemein lässt sich über die \textit{Zeitkomplexität} des A*\textit{Algorithmus} keine Aussage treffen, da diese von der \textit{Heuristik}-Funktion $h(n)$ abhängt. Doch der "`Luftlinien"\,-Ansatz gilt als der Effektivste. Dafür ist er nur in gewissen Situationen anwendbar. Nämlich wenn die Zeit und Rechenleistung gegeben ist, um den gesamten \textit{Graphen} visualisieren zu lassen.
\section{Vergleichsstatistik und Fazit}
Die Zahlen sprechen für sich. Spitzenreiter oder Zweitbester in jeder Testkategorie zu sein macht den A*-\textit{Algorithmus} zum klaren Favoriten (\autoref{tab:comp}).
\begin{table}[h!]
\centering
\caption{Die drei Algorithmen im direkten Vergleich}
\label{tab:comp}
\vspace{10pt}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}} lrrrrlr}
	             & Laufzeit /$\mu s$  & Kosten      & Kanten     & versch.      & Knoten      & Sortierungen \\
\hline
\hline
\\
DFS	             & \textbf{72,61709}  & 116         & 10 	     & 24	        & 83          & 14           \\
Dijkstra         & 223,76864          & \textbf{78} & \textbf{6} & 36	        & 115         & 30 	         \\
\textbf{A*}	     & 109,71132 	      & 94          & \textbf{6} & \textbf{19}	& \textbf{29} & \textbf{11}  \\ 
\hline
\end{tabular*} 
\end{table}
\newpage
\section{Schluss}
\newpage

%\nocite{*}
%\bibliographystyle{plain}
%\bibliography{WSeminar}
\begin{thebibliography}{99}
\bibitem{navi} Stern.de: Kuriose Navi-Unfälle\\
\newblock http://www.stern.de/digital/technik/navi-missgeschicke--in-100-metern-fahren-sie------in-den-fluss-3087618.html \\\emph{zul. abgerufen am 27.10.15}

\bibitem{random} Java Zufalls-Funktion\\
\newblock http://docs.oracle.com/javase/7/docs/api/java/util/Random.html \\\emph{zul. abgerufen am 18.10.15}
\bibitem{javafx} JavaFX-Homepage\\
\newblock http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-overview.htm \\\emph{zul. abgerufen am 14.10.15}

\bibitem{force-directed} Stephen~G. Kobourov\\
\newblock "`Spring embedders and force directed graph drawing algorithms.", 2012\\
\newblock http://arxiv.org/pdf/1201.3011v1.pdf \\\emph{zul. abgerufen am 24.10.15}

\bibitem{force-directed2} Stephen~G. Kobourov\\
\newblock "`Force-Directed Drawing Algorithms", 2013\\
\newblock https://cs.brown.edu/~rt/gdhandbook/chapters/force-directed.pdf \\\emph{zul. abgerufen am 30.10.15}

\bibitem{fruchterman} Thomas M.~J. Fruchterman und Edward~M. Reingold\\
\newblock "`Graph drawing by force-directed placement", 1991\\
\newblock ftp://ftp.mathe2.uni-bayreuth.de/axel/papers/reingold:graph{\_}drawing{\_}by{\_}force{\_}directed{\_}\\placement.pdf \\\emph{zul. abgerufen am 24.10.15}

\bibitem{big-o} Donald E. Knuth\\
\newblock "`Big Omicron and big Omega and big Theta", S. 18--24, 1976\\
\newblock http://www.phil.uu.nl/datastructuren/09-10/knuth{\_}big{\_}omicron.pdf  \\\emph{zul. abgerufen am 30.10.15}

\clearpage

\bibitem{contr-hier} Robert Geisberger\\
\newblock "`Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks", 2008\\
\newblock http://algo2.iti.kit.edu/schultes/hwy/contract.pdf \\\emph{zul. abgerufen am 30.10.15}

\bibitem{cormen} Thomas H. Cormen\\
\newblock "`Introduction to Algorithms", 2. Ausgabe, 2001\\
\newblock http://www.mif.vu.lt/$\sim$valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf \\\emph{zul. abgerufen am 30.10.15}

\bibitem{interview} Thomas~J. Misa und Philip~L. Frana\\
\newblock "`An interview with Edsger W. Dijkstra"\\
\newblock {\em Commun. ACM}, 53(8):41--47, 2010\\
\newblock http://dl.acm.org/citation.cfm?doid=1787234.1787249 \\\emph{zul. abgerufen am 01.11.15}

\bibitem{astar} P.E. Hart, N.J. Nilsson, und B.~Raphael\\
\newblock "`A formal basis for the heuristic determination of minimum cost paths"\\
\newblock {\em Systems Science and Cybernetics, IEEE Transactions on}, 4(2):100--107, 1968\\
\newblock http://ai.stanford.edu/$\sim$nilsson/OnlinePubs-Nils/PublishedPapers/astar.pdf \\\emph{zul. abgerufen am 03.11.15}

\bibitem{heuristics} Peter M. Todd und Gerd Gigerenzer\\
\newblock "`Précis of `Simple heuristics that make us smart'", S. 727--780, 2000\\
\newblock http://psy2.ucsd.edu/$\sim$mckenzie/ToddGigerenzer2000BBS.pdf \\\emph{zul. abgerufen am 03.11.15}

\end{thebibliography}
\newpage

%\includepdf{res/GraphGenerator.pdf}

%\includepdf{res/DFS.pdf}

\includepdf[pages=2, pagecommand={\thispagestyle{plain}}]{res/deckblatt_erklaerung.pdf}
\end{document}
